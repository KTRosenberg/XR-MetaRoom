<!DOCTYPE html>
<head>
  <!-- WebXR Shim is taken from @immersive-web/webxr-examples; it attempts to
    patch browser inconsistencies similar to the webxr-polyfill.js.  According
    to its authors, it will be unnecessary soon after the production WebXR impl
    is shipped. -->
  <script src="js/webxr-version-shim.js"></script>
  <!-- WebXR Button implements a button to toggle in and out of VR. -->
  <script src="js/webxr-button.js"></script>
  <!-- WebXR Canvas Wrangler simplifies WebXR setup. -->
  <script src="js/webxr-wrangler.js"></script>
</head>
<body style="background-color: black; color: white; text-emphasis-color: white;">
  <div style="text-align: center">
    <div style="text-align: center;" id=output-element></div>
  </div>
  <script>
    "use strict";
    // README
    //
    // This page's javascript is broken into two sections:
    // (1) WebGL + content setup (to be played with by student);
    // (2) WebXR setup (boilerplate).
    //
    // I hope to eventually move all boilerplate to a standalone
    // javascript file (perhaps "webxr-support.js") at a later date.

    //
    // (1) WEBGL + CONTENT SETUP
    //

    // Global vars for rendered content.
    let gl = null;
    let program = null;
    let vert = null;
    let frag = null;

    let model = null;  // uniform
    let view = null;   // uniform
    let proj = null;   // uniform
    let time = null;   // uniform

    let compileCount = null; // uniform

    let localCompileCount = 0;

    let start = null;

    // (KTR) TODO, need to reset the clock upon loading a new world -- 
    // will need to track "now" and update "start"
    
    // A simple vertex / fragment shader from K.P. lib1.js.
    vert = `
attribute vec3 aPos;
varying   vec3 vPos;
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

void main() {
  gl_Position = uProj * uView * uModel * vec4(aPos, 1.);
  vPos = aPos;
}`;

    frag = `
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
  
varying vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  gl_FragColor = vec4(sqrt(color), 1.0);
}`;

    // (KTR) Rewrite in modern GLSL ES,  A simple vertex / fragment shader from K.P. lib1.js.
    let vertModern = `#version 300 es
in vec3 aPos; // attributes replaced with "in"
out   vec3 vPos; // varying output replaced with "out"
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

uniform   int uCompileCount;
uniform   float uTime;

void main() {
  float translation = float(uCompileCount) * uTime + (10.0 * float(uCompileCount));
  gl_Position = uProj * uView * uModel * vec4(vec3(aPos.x + sin(translation), aPos.y - sin(translation), aPos.z), 1.);
  vPos = aPos;
}`;

    let fragModern = `#version 300 es
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
// varying input replaced with "in"  
in vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0

out vec4 fragColor; // gl_FragColor replaced with an explicit "out" vec4 that you set in the shader
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  fragColor = vec4(sqrt(color), 1.0);
}`;

    // Taken from K.P.'s lib1.js support library.
    function setup(modern = false) {

      // Create shader program
      program = gl.createProgram();
      function addShader(type, src) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          let msg = gl.getShaderInfoLog(shader);

          let shaderTypename = '';
          switch (type) {
          case gl.VERTEX_SHADER: {
            shaderTypename = "vertex";
            break;
          }
          case gl.FRAGMENT_SHADER: {
            shaderTypename = "fragment";
            break;
          }
          default:
            break;
          }
          console.error("Cannot compile " + shaderTypename + " shader:\n\n" + msg);
        } else {
          gl.attachShader(program, shader);
        }
      }

      if (modern) {
        addShader(gl.VERTEX_SHADER, vertModern);
        addShader(gl.FRAGMENT_SHADER, fragModern);
      }
      else {
        addShader(gl.VERTEX_SHADER, vert);
        addShader(gl.FRAGMENT_SHADER, frag);
      }
      gl.linkProgram(program);
      if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
        let msg = gl.getProgramInfoLog(program);
        console.error("Cannot link program:\n\n" + msg);
      } else {
        gl.useProgram(program);
      }

      // Create a square as a triangle strip consisting of two triangles
      gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

      // Assign aPos attribute to each vertex
      let aPos = gl.getAttribLocation(program, 'aPos');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

      // Assign MVP matrices
      model = gl.getUniformLocation(program, 'uModel');
      view = gl.getUniformLocation(program, 'uView');
      proj = gl.getUniformLocation(program, 'uProj');
      time = gl.getUniformLocation(program, 'uTime');
      compileCount = gl.getUniformLocation(program, 'uCompileCount');

      gl.uniform1i(compileCount, localCompileCount);

      localCompileCount += 1;
    }

    // My WebXR boilerplate requires a few arguments:
    // (1) a handle to the WebGL (not 'xrpresent') context;
    // (2) callbacks for
    //     - onStartFrame(t) : called once per frame
    //     - onEndFrame(t)    : called once per frame
    //     - onDraw(t, p,v)     : called once per viewport (i.e. 2x on VR)
    //
    // In the future, I envision these three functions are left to the
    // enduser to implement.  They could easily be mapped to functions
    // of some 'renderer' class.  We shall see...

    function onStartFrame(t) {
      if (!start) {
        start = t;
      }

      let now = (t - start) / 1000.;
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.uniform1f(time, now);
    }

    function onDraw(t, projMat, viewMat) {
      gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
      gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
      gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      console.log("onDraw1");
    }

    function onEndFrame(t) {
    }

    function onDraw2(t, projMat, viewMat) {
      gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
      gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
      gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      console.log("onDraw2: " + t);
    }



    //
    // (2) WEBXR BOILERPLATE
    //

    // Apply the version shim.  This shouldn't be needed once WebXR is widely adopted.
    const shim = new WebXRVersionShim();

    // Wrangle them canvases!
    // const wrangler = new XRCanvasWrangler(document.querySelector('#output-canvas'), {
    //   onStartFrame: onStartFrame,
    //   onEndFrame: onEndFrame,
    //   onDraw: onDraw
    // });
    const wrangler = new XRCanvasWrangler({
      outputSurfaceName: 'output-element',
      onStartFrame: onStartFrame,
      onEndFrame: onEndFrame,
      onDraw: onDraw,
      onSelectStart: function(t, state) {
        console.log("selected");
        wrangler.simulateCanvasTransition();
      },
      outputWidth: 400,
      outputHeight: 400,
    });
    // The wrangler should have bound itself to canvas#output-canvas - we may safely request
    // access to the WebGL context.
    gl = wrangler.gl;

    setup();

    wrangler.simulateCanvasTransition = function() {
      wrangler.options.onDraw = onDraw2;
      onWorldVisit(wrangler);
      if (gl !== undefined) {
        gl = wrangler.gl;
      }
      setup(true); // (KTR) For the testing, I need to redo the WebGL initialization
    }

  </script>
</body>