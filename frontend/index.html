<!DOCTYPE html>
<head>
  <!-- WebXR Shim is taken from @immersive-web/webxr-examples; it attempts to
    patch browser inconsistencies similar to the webxr-polyfill.js.  According
    to its authors, it will be unnecessary soon after the production WebXR impl
    is shipped. -->
  <script src="js/webxr-version-shim.js"></script>
  <!-- WebXR Button implements a button to toggle in and out of VR. -->
  <script src="js/webxr-button.js"></script>
  <!-- WebXR Canvas Wrangler simplifies WebXR setup. -->
  <script src="js/webxr-wrangler.js"></script>
</head>
<body style="background-color: black; color: white; text-emphasis-color: white;">
  <div style="text-align: center">
    <div style="text-align: center;" id=output-element></div>
  </div>
  <script>
    "use strict";
    // README
    //
    // This page's javascript is broken into two sections:
    // (1) WebGL + content setup (to be played with by student);
    // (2) WebXR setup (boilerplate).
    //
    // I hope to eventually move all boilerplate to a standalone
    // javascript file (perhaps "webxr-support.js") at a later date.

    //
    // (1) WEBGL + CONTENT SETUP
    //

    // Global vars for rendered content.
    let program = null;
    let vert = null;
    let frag = null;

    let model = null;  // uniform
    let view = null;   // uniform
    let proj = null;   // uniform
    let time = null;   // uniform

    let compileCount = null; // uniform

    let localCompileCount = 0;

    let start = null;

    // (KTR) TODO, need to reset the clock upon loading a new world -- 
    // will need to track "now" and update "start"
    
    // A simple vertex / fragment shader from K.P. lib1.js.
    vert = `
attribute vec3 aPos;
varying   vec3 vPos;
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

void main() {
  gl_Position = uProj * uView * uModel * vec4(aPos, 1.);
  vPos = aPos;
}`;

    frag = `
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
  
varying vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  gl_FragColor = vec4(sqrt(color), 1.0);
}`;

    // (KTR) Rewrite in modern GLSL ES,  A simple vertex / fragment shader from K.P. lib1.js.
    let vertModern = `#version 300 es
in vec3 aPos; // attributes replaced with "in"
out   vec3 vPos; // varying output replaced with "out"
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

uniform   int uCompileCount;
uniform   float uTime;

void main() {
  float translation = float(uCompileCount) * uTime + (10.0 * float(uCompileCount));
  gl_Position = uProj * uView * uModel * vec4(vec3(aPos.x + sin(translation), aPos.y - sin(translation), aPos.z), 1.);
  vPos = aPos;
}`;

    let fragModern = `#version 300 es
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
// varying input replaced with "in"  
in vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0

out vec4 fragColor; // gl_FragColor replaced with an explicit "out" vec4 that you set in the shader
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  fragColor = vec4(sqrt(color), 1.0);
}`;

    function addShader(type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let msg = gl.getShaderInfoLog(shader);

        let shaderTypename = '';
        switch (type) {
        case gl.VERTEX_SHADER: {
          shaderTypename = "vertex";
          break;
        }
        case gl.FRAGMENT_SHADER: {
          shaderTypename = "fragment";
          break;
        }
        default:
          break;
        }
        console.error("Cannot compile " + shaderTypename + " shader:\n\n" + msg);
        return null;
      } else {
        gl.attachShader(program, shader);
        return shader;
      }
    }


    const setupFunctions = [];
      // Taken from K.P.'s lib1.js support library.
      setupFunctions.push(function (modern = false) {
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vertModern);
          fshader = addShader(gl.FRAGMENT_SHADER, fragModern);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, frag);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.useProgram(program);
        }

        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });

      setupFunctions.push(
      function (modern = false) {
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vertModern);
          fshader = addShader(gl.FRAGMENT_SHADER, fragModern);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, frag);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.deleteShader(vshader);

          gl.useProgram(program);
        }
        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });




    // My WebXR boilerplate requires a few arguments:
    // (1) a handle to the WebGL (not 'xrpresent') context;
    // (2) callbacks for
    //     - onStartFrame(t) : called once per frame
    //     - onEndFrame(t)    : called once per frame
    //     - onDraw(t, p,v)     : called once per viewport (i.e. 2x on VR)
    //
    // In the future, I envision these three functions are left to the
    // enduser to implement.  They could easily be mapped to functions
    // of some 'renderer' class.  We shall see...

    function onStartFrame(t) {
      if (!start) {
        start = t;
      }

      let now = (t - start) / 1000.;
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.uniform1f(time, now);
    }

    const drawFunctions = [
      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      },

      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    ];
    let worldIdx = 0;

    function onEndFrame(t) {
    }



    //
    // (2) WEBXR BOILERPLATE
    //

    // Apply the version shim.  This shouldn't be needed once WebXR is widely adopted.
    const shim = new WebXRVersionShim();

    // Wrangle them canvases!
    // const wrangler = new XRCanvasWrangler(document.querySelector('#output-canvas'), {
    //   onStartFrame: onStartFrame,
    //   onEndFrame: onEndFrame,
    //   onDraw: onDraw
    // });
    const wrangler = new XRCanvasWrangler();


    wrangler.init({
      outputSurfaceName: 'output-element',
      outputWidth: 400,
      outputHeight: 400,
      glUseGlobalContext: true
    }).then((window) => {

      // system calls user program after the initial set-up is complete
      // (e.g. wait for the XR promise to resolve)

      const myWorld = wrangler;

      myWorld.configure({
        setup: setupFunctions[0],
        onStartFrame: onStartFrame,
        onEndFrame: onEndFrame,
        onDraw: drawFunctions[0],
        onSelectStart: function(t, state) {
          console.log("selected");
          wrangler.simulateCanvasTransition();
        },
      });

      myWorld.start();

      wrangler.simulateCanvasTransition = function() {

        worldIdx = (worldIdx + 1) % drawFunctions.length;

        wrangler._reset();

        myWorld.configure({
          setup: function() { setupFunctions[worldIdx](true); },
          onStartFrame: onStartFrame,
          onEndFrame: onEndFrame,
          onDraw: drawFunctions[worldIdx],
          onSelectStart: function(t, state) {
            console.log("selected");
            wrangler.simulateCanvasTransition();
          },
        });

        

        wrangler.start();
      }

    });

  </script>
</body>