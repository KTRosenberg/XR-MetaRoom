<!DOCTYPE html>
<head>
  <!-- WebXR Shim is taken from @immersive-web/webxr-examples; it attempts to
    patch browser inconsistencies similar to the webxr-polyfill.js.  According
    to its authors, it will be unnecessary soon after the production WebXR impl
    is shipped. -->
  <script src="js/webxr-version-shim.js"></script>
  <!-- WebXR Button implements a button to toggle in and out of VR. -->
  <script src="js/webxr-button.js"></script>
  <!-- WebXR Canvas Wrangler simplifies WebXR setup. -->
  <script src="js/webxr-wrangler.js"></script>


<script id="Connor_shader2_vertex" type="x-shader/x-vertex">
   precision highp float;
   attribute vec3 aPos;
   varying   vec3 vPosition;
   uniform   mat4 uModel;
   uniform   mat4 uView;
   uniform   mat4 uProj;
   uniform   float uTime;

   void main() {
      vec3 aPosition = aPos;
      gl_Position = uProj * uView * uModel * vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>
<script id="Connor_shader2_fragment" type="x-shader/x-fragment">
    precision highp float;
    uniform float uTime;
    uniform float uIntensity;
    varying vec3  vPosition;

    #define M_PI 3.1415926535897932384626433832795

    // is v within a circle of center c and radius r?
    bool circle(vec2 v, vec2 c, float r) {
        return distance(v, c) <= r;
    }

    vec3 func(vec2 pos, float t, vec3 c) {
        vec3 color = vec3(0);
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                float minx = float(i) / 5.0 - 1.0;
                float maxx = float(i+1) / 5.0 - 1.0;
                float miny = 2.0 * sin((t + float(i) / 20. - float(j) / 20.0) * M_PI / 3.) / 2.0 + float(j) / 5.0 - 2.0;
                float maxy = 4.0 * sin((t + float(i) / 20. - float(j) / 20.0) * M_PI / 3.) / 2.0 + float(j) / 5.0 - 2.0;
                if (pos.x >= minx && pos.x < maxx && pos.y >= miny && pos.y < maxy) {
                    color = vec3(1.0 - float(i) / 10.0, float(j) / 10.0, float(i+j) / 20.0);
                }
            }
        }
        return color;
    }

    void main() {
        vec2 pos = vPosition.xy;
        vec3 color = vec3(0.0);
        
        float t = uTime;
        color += func(pos, t, color);
        gl_FragColor = vec4(color, 1.0);
    }

</script>

<script id="KTR_a3-2017_fragment" type="x-shader/x-fragment">
precision highp float;
varying vec3 vPos;                               /* Position in image */
uniform float uTime;                             /* Time */

#define MY_MAX_FLOAT (50.)

/* light directions */

/* enable specific light directions */
#define BRIGHT_1 true
#define BRIGHT_2 false
#define BRIGHT_3 true

vec3 LDir = normalize(vec3(1.,-sin(uTime),.5));  
vec3 LDir2 = normalize(vec3(-cos(uTime),0.,.5));           
vec3 LDir3 = normalize(vec3(1., sin(uTime), sin(uTime)));

#define NUM_SPHERES (3)

/* 
 * constants for calculating where to darken pixels for generating a "texture"
 * on the spheres
 */
#define TEXTURE_CONST (uTime)
#define TEXTURE_CONST_2 (-cos(uTime))

/*
 * packages values required to
 * ray-trace and render a sphere
 */
struct sphere {
    vec3 V;
    vec3 W;
    vec4 S;
    vec2 t;
};

/* holds each sphere struct */
sphere spheres[NUM_SPHERES];

/*
 * initializes a sphere struct, omitting t
 *
 * param:
 *     vec3, V
 *         ray origin
 *     vec3, W
 *         normalized ray direction
 *     vec4, S
 *         sphere coordinates and radius
 *         x, y, z, r
 * return:
 *     sphere struct
 */
sphere init_sphere(vec3 V, vec3 W, vec4 S)
{   
    sphere s;
    s.V = V;
    s.W = W;
    s.S = S;
    return s;
}

/*
 * ray-traces a sphere
 * 
 * param:
 *     sphere
 *         the sphere to ray-trace
 * return:
 *     vec2
 *         t vector
 */
vec2 raytraceSphere(sphere s)
{
    vec3 V = s.V;
    vec3 W = s.W;
    vec4 S = s.S;

    V -= S.xyz;
    float B = 2. * dot(V, W);
    float C = dot(V, V) - S.w * S.w;;
    float discrim = B * B - 4. * C;
    return ((discrim < 0.) ? vec2(-1., -1) 
                          : vec2(-B - discrim, -B + discrim) / 2.);
}

/* same as above, but individual values passed, created by Professor Perlin */
vec2 raytraceSphere(vec3 V, vec3 W, vec4 S)
{
    V -= S.xyz;
    float B = 2. * dot(V, W);
    float C = dot(V, V) - S.w * S.w;;
    float discrim = B * B - 4. * C;
    return ((discrim < 0.) ? vec2(-1., -1)
                           : vec2(-B - discrim, -B + discrim) / 2.);
}

int get_idx_sphere_to_draw(void)
{
    int index = -1;
    float min_t_x = MY_MAX_FLOAT;
    
    for (int i = 0; i < NUM_SPHERES; i++) {
        float t_x = spheres[i].t.x;
        if (t_x > 0. && t_x < min_t_x) {
            index = i;
            min_t_x = t_x;
        }
    }
    return index;
}

/*
 * calculates the brightness with hard-coded light directions
 * and a given normal
 * 
 * param:
 *     vec3 N
 *         the surface normal
 * return:
 *     float
 *         brightness value
 */
float calc_brightness(vec3 N)
{
    float brightness  = (BRIGHT_1) ? max(0., dot(N, LDir)) : 0.;
    float brightness2 = (BRIGHT_2) ? max(0., dot(N, LDir2)) : 0.;
    float brightness3 = (BRIGHT_3) ? max(0., dot(N, LDir3)) : 0.;
    return (mix(.1, brightness + brightness2 + brightness3, .5));
}

/* 
 * generates texture to mix into the sphere color
 *
 * param:
 *     vec2 p 
 *         manipulated x,y pixel coordinated value
 *         to be manipulated further
 * return
 *     float
 *         non-positive value will darken the pixel
 */
float calc_pattern(vec2 p)
{
    return (sin(TEXTURE_CONST) 
            + sin((TEXTURE_CONST_2 * p.y * p.x) 
            + cos(p.x) * .01));
}

void main(void)
{
    /* dynamic background -- moving red-tinted gradient */
    vec3 c = vec3(.1 * sin(vPos.y + uTime), .01, .04) + 0.005 * vPos.x;
    
    /* first sphere */
    
    /* ray origin */
    /* ray direction */
    /* animate sphere */
    spheres[0] = init_sphere(vec3(0., 0., 0.), 
                             normalize(vec3(vPos.xy, -3.)),  
                             vec4(cos(uTime), sin(uTime), -5., .5));
    /* ray trace sphere */
    spheres[0].t = raytraceSphere(spheres[0]); 
    
    /* second sphere */
    spheres[1] = init_sphere(vec3(0., 0., 0.), 
                             normalize(vec3(vPos.xy, sin(uTime))),
                             vec4(cos(uTime),sin(uTime), -5., .5));           
    spheres[1].t = raytraceSphere(spheres[1]);

    /* third sphere */
    spheres[2] = init_sphere(vec3(0., 0., 9.), 
                             normalize(vec3(vPos.xy, -3)),  
                             vec4(cos(uTime), -sin(uTime), -3., .5));           
    spheres[2].t = raytraceSphere(spheres[2]);

    int sphere_idx = get_idx_sphere_to_draw();
    if (sphere_idx != -1) {
        for (int i = 0; i < NUM_SPHERES; i++) {
            if (i == sphere_idx) {
                /* point on sphere */
                vec3 P = spheres[i].V + spheres[i].t.x * spheres[i].W;
                /* Surface normal */
                vec3 N = normalize(P - spheres[i].S.xyz);
                /* brightness for diffuse surface */
                float brightness = calc_brightness(N);
                c = vec3(2. * vPos.y + sin(uTime), 0.0, .2) * brightness;

                float z = calc_pattern(4. * vPos.xy);
                if (z > 0.) {
                    c = mix(c, vec3(1., 1., 1.), c);
                }
            }
        }
    }

    gl_FragColor = vec4(sqrt(c), 1.);             // final pixel color
}
</script>



</head>
<body style="background-color: black; color: white; text-emphasis-color: white;">
  <div style="text-align: center">
    <div style="text-align: center;" id=output-element></div>
  </div>
  <script>
    "use strict";
    // README
    //
    // This page's javascript is broken into two sections:
    // (1) WebGL + content setup (to be played with by student);
    // (2) WebXR setup (boilerplate).
    //
    // I hope to eventually move all boilerplate to a standalone
    // javascript file (perhaps "webxr-support.js") at a later date.

    //
    // (1) WEBGL + CONTENT SETUP
    //

    // Global vars for rendered content.
    let program = null;
    let vert = null;
    let frag = null;

    let model = null;  // uniform
    let view = null;   // uniform
    let proj = null;   // uniform
    let time = null;   // uniform

    let compileCount = null; // uniform

    let localCompileCount = 0;

    let start = null;

    // (KTR) TODO, need to reset the clock upon loading a new world -- 
    // will need to track "now" and update "start"
    
    // A simple vertex / fragment shader from K.P. lib1.js.
    vert = `
precision highp float;
attribute vec3 aPos;
varying   vec3 vPos;
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

void main() {
  gl_Position = uProj * uView * uModel * vec4(aPos, 1.);
  vPos = aPos;
}`;

    frag = `
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
  
varying vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  gl_FragColor = vec4(sqrt(color), 1.0);
}`;

    // (KTR) Rewrite in modern GLSL ES,  A simple vertex / fragment shader from K.P. lib1.js.
    let vertModern = `#version 300 es
in vec3 aPos; // attributes replaced with "in"
out   vec3 vPos; // varying output replaced with "out"
uniform   mat4 uModel;
uniform   mat4 uView;
uniform   mat4 uProj;

uniform   int uCompileCount;
uniform   float uTime;

void main() {
  float translation = float(uCompileCount) * uTime + (10.0 * float(uCompileCount));
  gl_Position = uProj * uView * uModel * vec4(vec3(aPos.x + sin(translation), aPos.y - sin(translation), aPos.z), 1.);
  vPos = aPos;
}`;

    let fragModern = `#version 300 es
precision highp float;
uniform float uTime;   // TIME, IN SECONDS
// varying input replaced with "in"  
in vec3 vPos;     // -1 < vPos.x < +1
// -1 < vPos.y < +1
//      vPos.z == 0

out vec4 fragColor; // gl_FragColor replaced with an explicit "out" vec4 that you set in the shader
  
void main() {    // YOU MUST DEFINE main()
    
  // HERE YOU CAN WRITE ANY CODE TO
  // DEFINE A COLOR FOR THIS FRAGMENT

  float red   = max(0., vPos.x);
  float green = max(0., vPos.y);
  float blue  = max(0., sin(5. * uTime));
  
  // R,G,B EACH RANGE FROM 0.0 TO 1.0
    
  vec3 color = vec3(red, green, blue);
    
  // THIS LINE OUTPUTS THE FRAGMENT COLOR
    
  fragColor = vec4(sqrt(color), 1.0);
}`;




const vertConnor = document.getElementById('Connor_shader2_vertex').innerHTML;
const fragConnor = document.getElementById('Connor_shader2_fragment').innerHTML;

const fragKTRa32017 = document.getElementById('KTR_a3-2017_fragment').innerHTML;



    function addShader(type, src) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        let msg = gl.getShaderInfoLog(shader);

        let shaderTypename = '';
        switch (type) {
        case gl.VERTEX_SHADER: {
          shaderTypename = "vertex";
          break;
        }
        case gl.FRAGMENT_SHADER: {
          shaderTypename = "fragment";
          break;
        }
        default:
          break;
        }
        console.error("Cannot compile " + shaderTypename + " shader:\n\n" + msg);
        return null;
      } else {
        gl.attachShader(program, shader);
        return shader;
      }
    }


    const setupFunctions = [];
      // Taken from K.P.'s lib1.js support library.
      setupFunctions.push(function (modern = false) {
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vertModern);
          fshader = addShader(gl.FRAGMENT_SHADER, fragModern);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, frag);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.useProgram(program);
        }

        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });

      setupFunctions.push(
      function (modern = false) {
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vertModern);
          fshader = addShader(gl.FRAGMENT_SHADER, fragModern);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, frag);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.deleteShader(vshader);

          gl.useProgram(program);
        }
        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });


      setupFunctions.push(
      function (modern = false) {
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vertConnor);
          fshader = addShader(gl.FRAGMENT_SHADER, fragConnor);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vertConnor);
          fshader = addShader(gl.FRAGMENT_SHADER, fragConnor);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.deleteShader(vshader);

          gl.useProgram(program);
        }
        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });

      setupFunctions.push(function (modern = false) {

        console.log("KTR");
        // Create shader program
        program = gl.createProgram();

        let vshader = null;
        let fshader = null;
        if (modern) {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, fragKTRa32017);
        }
        else {
          vshader = addShader(gl.VERTEX_SHADER, vert);
          fshader = addShader(gl.FRAGMENT_SHADER, fragKTRa32017);
        }
        gl.linkProgram(program);
        if (! gl.getProgramParameter(program, gl.LINK_STATUS)) {
          let msg = gl.getProgramInfoLog(program);
          console.error("Cannot link program:\n\n" + msg);
        } else {
          gl.detachShader(program, vshader);
          gl.detachShader(program, fshader);
          gl.deleteShader(vshader);
          gl.deleteShader(fshader);

          gl.useProgram(program);
        }

        // Create a square as a triangle strip consisting of two triangles
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1,0, 1,1,0, -1,-1,0, 1,-1,0]), gl.STATIC_DRAW);

        // Assign aPos attribute to each vertex
        let aPos = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

        // Assign MVP matrices
        model = gl.getUniformLocation(program, 'uModel');
        view = gl.getUniformLocation(program, 'uView');
        proj = gl.getUniformLocation(program, 'uProj');
        time = gl.getUniformLocation(program, 'uTime');
        compileCount = gl.getUniformLocation(program, 'uCompileCount');

        gl.uniform1i(compileCount, localCompileCount);

        localCompileCount += 1;
      });





    // My WebXR boilerplate requires a few arguments:
    // (1) a handle to the WebGL (not 'xrpresent') context;
    // (2) callbacks for
    //     - onStartFrame(t) : called once per frame
    //     - onEndFrame(t)    : called once per frame
    //     - onDraw(t, p,v)     : called once per viewport (i.e. 2x on VR)
    //
    // In the future, I envision these three functions are left to the
    // enduser to implement.  They could easily be mapped to functions
    // of some 'renderer' class.  We shall see...

    function onStartFrame(t) {
      if (!start) {
        start = t;
      }

      let now = (t - start) / 1000.;
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.uniform1f(time, now);
    }

    const drawFunctions = [
      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      },

      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      },

      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      },

      function (t, projMat, viewMat) {
        gl.uniformMatrix4fv(model, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-1,1]));
        gl.uniformMatrix4fv(view, false, new Float32Array(viewMat));
        gl.uniformMatrix4fv(proj, false, new Float32Array(projMat));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      },
    ];
    let worldIdx = 0;

    function onEndFrame(t) {
    }



    //
    // (2) WEBXR BOILERPLATE
    //

    // Apply the version shim.  This shouldn't be needed once WebXR is widely adopted.
    const shim = new WebXRVersionShim();

    // Wrangle them canvases!
    // const wrangler = new XRCanvasWrangler(document.querySelector('#output-canvas'), {
    //   onStartFrame: onStartFrame,
    //   onEndFrame: onEndFrame,
    //   onDraw: onDraw
    // });
    const wrangler = new XRCanvasWrangler();

    wrangler.init({
      outputSurfaceName : 'output-element',
      outputWidth : 400,
      outputHeight : 400,
      glUseGlobalContext : true,
      glDoResourceTracking : true,
      main : () => {
        // system calls user program after the initial set-up is complete
        // (e.g. wait for the XR promise to resolve)

        const myWorld = wrangler;

        myWorld.configure({
          setup: setupFunctions[0],
          onStartFrame: onStartFrame,
          onEndFrame: onEndFrame,
          onDraw: drawFunctions[0],
          onSelectStart: function(t, state) {
            console.log("on select start -- why is this fired twice???");
            wrangler.simulateCanvasTransition();
          },
          onSelect: function(t, state) {
            console.log("on select");
            wrangler.simulateCanvasTransition();
          }
        });

        myWorld.start();

        wrangler.simulateCanvasTransition = function() {

          worldIdx = (worldIdx + 1) % drawFunctions.length;

          gl.useProgram(null);

          wrangler._reset();
          wrangler._glFreeResources();

          myWorld.configure({
            setup: function() { setupFunctions[worldIdx](true); },
            onStartFrame: onStartFrame,
            onEndFrame: onEndFrame,
            onDraw: drawFunctions[worldIdx],
            // onSelectStart: function(t, state) {
            //   console.log("selected");
            //   wrangler.simulateCanvasTransition();
            // },
          });

          wrangler.start();
        }
      }

    });

  </script>
</body>